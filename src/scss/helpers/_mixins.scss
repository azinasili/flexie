// ----------------------------------------------------------------------------
// Helpers
// Mixins for various use cases
//
// 1. Screen size tool
// 2. PX to EM conversion tool
// 3. PX to REM conversion tool
// 4. CSS triangles
// 5. Traverse maps
// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// 1. Screen size tool
// ----------------------------------------------------------------------------

// Set width based on user given size
// Default screen size is the medium width
@mixin screen-size($size: $screen-size-medium) {
  @include em(max-width, $size);
  margin-left: auto;
  margin-right: auto;
  width: 100%;
}

// Screen size alias
@mixin ss($args...) {
  @include screen-size($args...);
}


// ----------------------------------------------------------------------------
// 2. PX to EM conversion tool
// ----------------------------------------------------------------------------

// Accepts any property with dimension value
// https://gist.github.com/webgefrickel/4530526
@mixin em($property, $values) {
  // Create a couple of empty lists as output buffers.
  $font-size: $font-base;
  $em-values: ();

  // Loop through the $values list
  @each $value in $values {
    // For each property value, if it's in em or px, derive both em and
    // px values for it and add those to the end of the appropriate buffer.
    // Ensure all pixel values are rounded to the nearest pixel.
    @if $value == 0 or $value == 0px {
      // 0 -- use it without a unit
      $em-values: join($em-values, 0);
    } @else if type-of($value) == number and not unitless($value) and (unit($value) == 'px') {
      // px value given - calculate em value from font-size
      $new-em-value: $value / $font-size;
      $em-values: join($em-values, #{$new-em-value}em);
    } @else if type-of($value) == number and not unitless($value) and (unit($value) == '%') {
      // % value given - don't add px or em
      $em-values: join($em-values, #{$value});
    } @else if $value == auto or $value == inherit or $value == initial {
      // auto - don't add px or em
      $em-values: join($em-values, $value);
    } @else {
      // unitless value - use those directly as em and calculate the px-fallback
      $em-values: join($em-values, #{$value}em);
    }
  }

  // output the converted rules
  #{$property}: $em-values;
}


// ----------------------------------------------------------------------------
// 3. PX to REM conversion tool
// ----------------------------------------------------------------------------

// Accepts any property with dimension value
// https://gist.github.com/webgefrickel/4530526
@mixin rem($property, $values) {
  // Create a couple of empty lists as output buffers.
  $font-size: $font-base;
  $rem-values: ();

  // Loop through the $values list
  @each $value in $values {
    // For each property value, if it's in rem or px, derive both rem and
    // px values for it and add those to the end of the appropriate buffer.
    // Ensure all pixel values are rounded to the nearest pixel.
    @if $value == 0 or $value == 0px {
      // 0 -- use it without a unit
      $rem-values: join($rem-values, 0);
    } @else if type-of($value) == number and not unitless($value) and (unit($value) == 'px') {
      // px value given - calculate rem value from font-size
      $new-rem-value: $value / $font-size;
      $rem-values: join($rem-values, #{$new-rem-value}rem);
    } @else if type-of($value) == number and not unitless($value) and (unit($value) == '%') {
      // % value given - don't add px or rem
      $rem-values: join($rem-values, #{$value});
    } @else if $value == auto or $value == inherit or $value == initial {
      // auto - don't add px or rem
      $rem-values: join($rem-values, $value);
    } @else {
      // unitless value - use those directly as rem and calculate the px-fallback
      $rem-values: join($rem-values, #{$value}rem);
    }
  }

  // output the converted rules
  #{$property}: $rem-values;
}


// ----------------------------------------------------------------------------
// 4. CSS triangles
// ----------------------------------------------------------------------------

// Mixin to easily create triangles
// @param {number} [$direction] - up, down, left, right, top-right, top-left, bottom-right, bottom-left
// @param {number} [$size] - Size of triangle
// @param {number} [$color] - Color of the element
@mixin triangle($direction, $size, $color) {
  // Check for em, rem, or px
  // Print proper sizing unit
  @if unit($size) == 'em' or unit($size) == 'rem' {
    border: $size solid transparent;
  } @else {
    border: rem($size) solid transparent;
  }

  // Get direction and color appropriate border side.
  @if $direction == down {
    border-top-color: $color;
  } @else if $direction == left {
    border-right-color: $color;
  } @else if $direction == up {
    border-bottom-color: $color;
  } @else if $direction == right {
    border-left-color: $color;
  } @else if $direction == up-left {
    border-left-color: $color;
    border-top-color: $color;
  } @else if $direction == up-right {
    border-right-color: $color;
    border-top-color: $color;
  } @else if $direction == down-right {
    border-bottom-color: $color;
    border-right-color: $color;
  } @else if $direction == down-left {
    border-bottom-color: $color;
    border-left-color: $color;
  }
}


// ----------------------------------------------------------------------------
// 5. Traverse maps
// ----------------------------------------------------------------------------
@mixin get-styles($map, $keys...) {
  $i: 1;
  $length: length($keys);

  // Get items from map
  @while $length >= $i {
    $map: map-get($map, nth($keys, $i));
    $i: $i + 1;
  }

  // Print styles that are not a map
  @each $property, $value in $map {
    @if type-of($value) != map {
      #{$property}: $value;
    }
  }
}
